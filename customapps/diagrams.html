<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diagram & Flowchart App</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add js-yaml library for YAML parsing -->
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* --- Shape Base Styles --- */
        .shape {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #3b82f6; /* blue-500 */
            background-color: #ffffff; /* white */
            padding: 12px;
            cursor: move;
            user-select: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            border-radius: 0.375rem; /* rounded-md */
            min-height: 50px;
            min-width: 100px;
            text-align: center;
            transition: box-shadow 0.2s ease, transform 0.2s ease;
        }
        
        .shape:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .shape.selected {
            border-color: #ef4444; /* red-500 */
            border-width: 3px;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.3);
        }
        
        .shape > div {
            outline: none;
            width: 100%;
            cursor: text;
        }

        /* --- Specific Shape Geometries --- */
        .rectangle {
            /* Default styles are rectangular */
        }

        .diamond {
            width: 150px;
            height: 100px;
            transform: rotate(45deg);
            transform-origin: center center;
        }
        .diamond > div {
            transform: rotate(-45deg);
            max-width: 100px;
        }

        .circle {
            width: 120px;
            height: 120px;
            border-radius: 50%;
        }
        
        .cloud {
            width: 150px;
            height: 100px;
            border: 2px solid #3b82f6;
            border-radius: 50px;
            position: relative;
        }
        .cloud:before, .cloud:after {
            content: '';
            position: absolute;
            background: #ffffff;
            border-top: 2px solid #3b82f6;
            z-index: -1;
        }
        .cloud:before {
            width: 80px; height: 80px;
            top: -40px; left: 20px;
            border-radius: 50%;
            border-right: 2px solid #3b82f6;
        }
        .cloud:after {
            width: 100px; height: 100px;
            top: -50px; right: 10px;
            border-radius: 50%;
            border-left: 2px solid #3b82f6;
        }
        /* We need to apply BG color to all parts for color picker */
        .shape.cloud, .shape.cloud:before, .shape.cloud:after {
            background-color: var(--shape-bg, #ffffff);
        }

        .person {
            width: 80px;
            height: 120px;
            border-radius: 0;
            padding: 0;
            border: none;
            background: none !important; /* Ignore color picker */
            box-shadow: none;
        }
        .person > div { /* Head */
            width: 50px;
            height: 50px;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            background-color: var(--shape-bg, #ffffff);
            position: absolute;
            top: 0;
            left: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            text-align: center;
            overflow: hidden;
            word-break: break-word;
        }
        .person:before { /* Body */
            content: '';
            width: 80px;
            height: 70px;
            border: 2px solid #3b82f6;
            border-radius: 30% 30% 10px 10px;
            background-color: var(--shape-bg, #ffffff);
            position: absolute;
            bottom: 0;
            left: 0;
        }
        /* Apply selection/color to both parts */
        .person.selected > div, .person.selected:before {
            border-color: #ef4444;
            border-width: 3px;
        }
        
        .display {
            width: 120px;
            height: 80px;
            border-radius: 10px 10px 0 0;
            position: relative;
            padding-bottom: 20px;
        }
        .display:after { /* Stand */
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 10px;
            background: #9ca3af; /* gray-400 */
            border-radius: 0 0 5px 5px;
            border: 2px solid #4b5563; /* gray-600 */
        }
        .display:before { /* Stand neck */
            content: '';
            position: absolute;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 10px;
            background: #6b7280; /* gray-500 */
        }
        
        
        /* --- Toolbar Shape Previews --- */
        .toolbar-item {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 70px; /* Made taller */
            border: 2px dashed #9ca3af; /* gray-400 */
            border-radius: 0.375rem; /* rounded-md */
            background-color: #f9fafb; /* gray-50 */
            cursor: grab;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            margin-bottom: 12px;
            /* Removed font styles */
            position: relative; /* Added */
            padding: 10px; /* Added */
            overflow: hidden; /* Added */
        }
        .toolbar-item:hover {
            background-color: #f3f4f6; /* gray-100 */
            border-color: #3b82f6; /* blue-500 */
        }

        /* --- NEW Toolbar Preview Styles --- */
        .toolbar-preview-shape {
            position: relative;
            border: 2px solid #3b82f6;
            background-color: #ffffff;
            border-radius: 0.375rem; /* rounded-md */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .rectangle-preview {
            width: 60px;
            height: 35px;
        }

        .diamond-preview {
            width: 45px;
            height: 45px;
            transform: rotate(45deg);
            transform-origin: center center;
            border-radius: 0;
        }

        .circle-preview {
            width: 45px;
            height: 45px;
            border-radius: 50%;
        }

        .cloud-preview {
            width: 60px;
            height: 40px;
            border-radius: 20px;
        }
        .cloud-preview:before, .cloud-preview:after {
            content: '';
            position: absolute;
            background: #ffffff;
            border-top: 2px solid #3b82f6;
            z-index: 1; /* Above parent border */
        }
        .cloud-preview:before {
            width: 30px; height: 30px;
            top: -15px; left: 8px;
            border-radius: 50%;
            border-right: 2px solid #3b82f6;
        }
        .cloud-preview:after {
            width: 40px; height: 40px;
            top: -20px; right: 5px;
            border-radius: 50%;
            border-left: 2px solid #3b82f6;
        }

        .person-preview {
            width: 40px;
            height: 50px;
            border-radius: 0;
            padding: 0;
            border: none;
            background: none !important;
        }
        .person-preview > div { /* Head */
            width: 25px;
            height: 25px;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            background-color: #ffffff;
            position: absolute;
            top: 0;
            left: 7.5px;
        }
        .person-preview:before { /* Body */
            content: '';
            width: 40px;
            height: 30px;
            border: 2px solid #3b82f6;
            border-radius: 30% 30% 5px 5px;
            background-color: #ffffff;
            position: absolute;
            bottom: 0;
            left: 0;
        }

        .display-preview {
            width: 50px;
            height: 35px;
            border-radius: 5px 5px 0 0;
            position: relative;
        }
        .display-preview:after { /* Stand */
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 5px;
            background: #9ca3af;
            border-radius: 0 0 2px 2px;
            border: 1px solid #4b5563;
        }
        .display-preview:before { /* Stand neck */
            content: '';
            position: absolute;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
            width: 10px;
            height: 5px;
            background: #6b7280;
        }
        /* --- End of Toolbar Preview Styles --- */


        /* --- SVG Connector Lines --- */
        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
        }
        .connector-line {
            stroke: #4b5563; /* gray-600 */
            stroke-width: 2;
        }

        /* --- Print Styles --- */
        @media print {
            .no-print {
                display: none !important;
            }
            #canvas {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                border: none;
                box-shadow: none;
                overflow: visible;
            }
            body {
                margin: 0;
                padding: 0;
            }
        }
    </style>
    <!-- Use Inter font -->
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>

<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white shadow-md p-4 flex justify-between items-center no-print">
        <h1 class="text-xl font-bold text-gray-800">Diagram App</h1>
        <div class="flex space-x-2">
            <button id="connect-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition-all shadow-sm">
                Connect Shapes
            </button>
            <button id="clear-btn" class="bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-lg transition-all shadow-sm">
                Clear Canvas
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex-1 flex overflow-hidden">

        <!-- Left Toolbar -->
        <aside class="w-48 bg-white p-4 overflow-y-auto shadow-lg no-print">
            <h2 class="text-lg font-semibold mb-3 text-gray-700">Shapes</h2>
            <div id="toolbar">
                <div class="toolbar-item" draggable="true" data-shape="rectangle">
                    <div class="toolbar-preview-shape rectangle-preview"></div>
                </div>
                <div class="toolbar-item" draggable="true" data-shape="diamond">
                    <div class="toolbar-preview-shape diamond-preview"></div>
                </div>
                <div class="toolbar-item" draggable="true" data-shape="circle">
                    <div class="toolbar-preview-shape circle-preview"></div>
                </div>
                <div class="toolbar-item" draggable="true" data-shape="cloud">
                    <div class="toolbar-preview-shape cloud-preview"></div>
                </div>
                <div class="toolbar-item" draggable="true" data-shape="person">
                    <div class="toolbar-preview-shape person-preview"><div></div></div>
                </div>
                <div class="toolbar-item" draggable="true" data-shape="display">
                    <div class="toolbar-preview-shape display-preview"></div>
                </div>
            </div>
        </aside>

        <!-- Canvas -->
        <main class="flex-1 bg-gray-200 overflow-auto p-4 relative">
            <div id="canvas" class="w-full h-[2000px] bg-white shadow-inner rounded-lg relative overflow-hidden">
                <!-- SVG Layer for Connectors -->
                <svg id="svg-layer">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#4b5563" />
                        </marker>
                    </defs>
                </svg>
                <!-- Shapes will be appended here by JS -->
            </div>
        </main>

        <!-- Right Properties Panel -->
        <aside class="w-64 bg-white p-4 overflow-y-auto shadow-lg no-print">
            <h2 class="text-lg font-semibold mb-3 text-gray-700">Properties</h2>
            
            <!-- Default message -->
            <div id="props-default" class="text-gray-500">
                Select a shape to edit its properties.
            </div>

            <!-- Editor -->
            <div id="props-editor" class="hidden space-y-4">
                <div>
                    <label for="text-input" class="block text-sm font-medium text-gray-700">Text</label>
                    <input type="text" id="text-input" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="color-input" class="block text-sm font-medium text-gray-700">Background Color</label>
                    <input type="color" id="color-input" value="#ffffff" class="mt-1 block w-full h-10 border-gray-300 rounded-md shadow-sm">
                </div>
                <button id="delete-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-lg transition-all shadow-sm">
                    Delete Shape
                </button>
            </div>
            
            <hr class="my-6 border-gray-300">
            
            <h2 class="text-lg font-semibold mb-3 text-gray-700">Tools</h2>
            <div class="space-y-3">
                <button id="print-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg transition-all shadow-sm no-print">
                    Print Diagram
                </button>
                <button id="export-yaml-btn" class="w-full bg-teal-500 hover:bg-teal-600 text-white font-medium py-2 px-4 rounded-lg transition-all shadow-sm no-print">
                    Export YAML
                </button>
                <!-- "Import" button is a styled label for a hidden file input -->
                <label for="import-yaml-input" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-4 rounded-lg transition-all shadow-sm cursor-pointer text-center block no-print">
                    Import YAML
                </label>
                <input type="file" id="import-yaml-input" class="hidden" accept=".yml,.yaml">
            </div>
        </aside>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- DOM Elements ---
            const canvas = document.getElementById('canvas');
            const svgLayer = document.getElementById('svg-layer');
            const propsDefault = document.getElementById('props-default');
            const propsEditor = document.getElementById('props-editor');
            const textInput = document.getElementById('text-input');
            const colorInput = document.getElementById('color-input');
            const deleteBtn = document.getElementById('delete-btn');
            const connectBtn = document.getElementById('connect-btn');
            const clearBtn = document.getElementById('clear-btn');
            const toolbarItems = document.querySelectorAll('.toolbar-item');
            const printBtn = document.getElementById('print-btn');
            const exportBtn = document.getElementById('export-yaml-btn');
            const importInput = document.getElementById('import-yaml-input');
            
            // --- Application State ---
            let shapes = []; // Stores shape data { id, x, y, text, color, type, element, connections }
            let lines = [];  // Stores line data { id, startShapeId, endShapeId, element }

            let shapeCounter = 0;
            let lineCounter = 0;
            
            let selectedShapeId = null;
            
            let isDragging = false;
            let currentDraggingElement = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;

            let isConnecting = false;
            let connectionStartShapeId = null;

            // --- Toolbar Drag & Drop ---
            toolbarItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', e.target.dataset.shape);
                    e.dataTransfer.effectAllowed = 'copy';
                });
            });

            canvas.addEventListener('dragover', (e) => {
                e.preventDefault(); // Allow dropping
                e.dataTransfer.dropEffect = 'copy';
            });

            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                const shapeType = e.dataTransfer.getData('text/plain');
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate drop position relative to the canvas
                let x = e.clientX - canvasRect.left;
                let y = e.clientY - canvasRect.top;

                // Create the shape
                createShape(shapeType, x, y);
            });
 
            // --- Shape Creation ---

            function buildShape(shapeData) {
                const shapeEl = document.createElement('div');
                shapeEl.id = shapeData.id;
                shapeEl.className = `shape ${shapeData.type}`;
                shapeEl.style.left = `${shapeData.x}px`;
                shapeEl.style.top = `${shapeData.y}px`;
                shapeEl.style.backgroundColor = shapeData.color;
                
                // Handle custom shape bg colors
                if (shapeData.type === 'person' || shapeData.type === 'cloud') {
                    shapeEl.style.setProperty('--shape-bg', shapeData.color);
                }

                // Add text container
                const textEl = document.createElement('div');
                textEl.innerText = shapeData.text;
                textEl.setAttribute('contenteditable', 'false');
                shapeEl.appendChild(textEl);

                // Make shape draggable on the canvas
                shapeEl.addEventListener('mousedown', onShapeMouseDown);
                // Select shape on click
                shapeEl.addEventListener('click', onShapeClick);
                // Edit text on double-click
                shapeEl.addEventListener('dblclick', onShapeDblClick);
                
                // Add to canvas
                canvas.appendChild(shapeEl);

                // Store in state
                const newShape = {
                    ...shapeData,
                    element: shapeEl,
                    connections: [] // Connections will be added by buildLine
                };
                shapes.push(newShape);
                return newShape;
            }

            function createShape(type, x, y) {
                const shapeId = `shape-${shapeCounter++}`;
                
                // Create a temporary element to measure
                const tempEl = document.createElement('div');
                tempEl.className = `shape ${type}`;
                tempEl.style.visibility = 'hidden';
                tempEl.style.position = 'absolute'; // Avoid layout shift
                canvas.appendChild(tempEl);
                const { offsetWidth, offsetHeight } = tempEl;
                canvas.removeChild(tempEl);

                // Adjust position to center the shape on the cursor
                x -= offsetWidth / 2;
                y -= offsetHeight / 2;
                
                // Ensure shape is within canvas bounds
                x = Math.max(0, x);
                y = Math.max(0, y);

                const shapeData = {
                    id: shapeId,
                    x: x,
                    y: y,
                    text: 'Text',
                    color: '#ffffff',
                    type: type,
                };
                
                buildShape(shapeData);
                selectShape(shapeId);
            }
 
            // --- Shape Movement on Canvas ---

            function onShapeMouseDown(e) {
                // Don't drag if in connection mode or editing text
                if (isConnecting || e.target.getAttribute('contenteditable') === 'true') return;
                
                e.preventDefault(); // Prevent text selection
                
                currentDraggingElement = this; // 'this' is the shapeEl
                const shape = findShapeById(currentDraggingElement.id);
                
                isDragging = true;
                
                // Calculate offset from the element's top-left corner
                dragOffsetX = e.clientX - shape.x;
                dragOffsetY = e.clientY - shape.y;
                
                // Select shape on mousedown
                selectShape(shape.id);

                // Add global listeners
                document.addEventListener('mousemove', onWindowMouseMove);
                document.addEventListener('mouseup', onWindowMouseUp);
            }

            function onWindowMouseMove(e) {
                if (!isDragging || !currentDraggingElement) return;

                const shape = findShapeById(currentDraggingElement.id);
                const canvasRect = canvas.getBoundingClientRect();

                // Calculate new position
                let newX = e.clientX - dragOffsetX;
                let newY = e.clientY - dragOffsetY;
                
                // Constrain to canvas boundaries
                newX = Math.max(0, Math.min(newX, canvas.clientWidth - currentDraggingElement.offsetWidth));
                newY = Math.max(0, Math.min(newY, canvas.clientHeight - currentDraggingElement.offsetHeight));

                // Update element style
                currentDraggingElement.style.left = `${newX}px`;
                currentDraggingElement.style.top = `${newY}px`;

                // Update state
                shape.x = newX;
                shape.y = newY;
                
                // Update connected lines
                updateLinesForShape(shape.id);
            }

            function onWindowMouseUp(e) {
                isDragging = false;
                currentDraggingElement = null;
                document.removeEventListener('mousemove', onWindowMouseMove);
                document.removeEventListener('mouseup', onWindowMouseUp);
            }

            // --- Shape Selection & Properties Panel ---

            function onShapeClick(e) {
                e.stopPropagation(); // Prevent canvas click
                
                if (isConnecting) {
                    handleConnectionClick(this.id); // 'this' is the shapeEl
                    return;
                }

                // If not dragging, select shape. (Drag handles selection in onShapeMouseDown)
                if (!isDragging) {
                    selectShape(this.id);
                }
            }

            canvas.addEventListener('click', () => {
                // Deselect when clicking canvas background
                if (!isConnecting) {
                    selectShape(null);
                }
            });

            function selectShape(shapeId) {
                // Clear old selection
                if (selectedShapeId) {
                    const oldShape = findShapeById(selectedShapeId);
                    if (oldShape) {
                        oldShape.element.classList.remove('selected');
                    }
                }

                selectedShapeId = shapeId;

                if (shapeId) {
                    // Set new selection
                    const shape = findShapeById(shapeId);
                    shape.element.classList.add('selected');
                    
                    // Update properties panel
                    propsDefault.classList.add('hidden');
                    propsEditor.classList.remove('hidden');

                    textInput.value = shape.text;
                    colorInput.value = shape.color;
                } else {
                    // No shape selected
                    propsDefault.classList.remove('hidden');
                    propsEditor.classList.add('hidden');
                }
            }

            // --- Property Editors ---

            textInput.addEventListener('input', (e) => {
                if (!selectedShapeId) return;
                const shape = findShapeById(selectedShapeId);
                const newText = e.target.value;
                
                shape.text = newText;
                shape.element.querySelector('div').innerText = newText;
            });

            colorInput.addEventListener('input', (e) => {
                if (!selectedShapeId) return;
                const shape = findShapeById(selectedShapeId);
                const newColor = e.target.value;
                
                shape.color = newColor;
                shape.element.style.backgroundColor = newColor;

                // Handle custom shape bg colors
                if (shape.type === 'person' || shape.type === 'cloud') {
                    shape.element.style.setProperty('--shape-bg', newColor);
                }
            });

            deleteBtn.addEventListener('click', () => {
                if (!selectedShapeId) return;
                
                // Remove all connected lines
                const shape = findShapeById(selectedShapeId);
                [...shape.connections].forEach(conn => { // Iterate over a copy
                    deleteLine(conn.lineId);
                });
                
                // Remove shape element
                shape.element.remove();
                
                // Remove from state
                shapes = shapes.filter(s => s.id !== selectedShapeId);
                
                // Clear selection
                selectShape(null);
            });
 
            // --- Direct Text Editing ---
            function onShapeDblClick(e) {
                e.stopPropagation();
                if (isConnecting) return;

                const textEl = this.querySelector('div');
                textEl.setAttribute('contenteditable', 'true');
                textEl.focus();
                
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(textEl);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);

                // Add blur listener to stop editing
                textEl.addEventListener('blur', onTextBlur, { once: true });
                textEl.addEventListener('keydown', onTextKeydown);
            }
            
            function onTextBlur(e) {
                const textEl = e.target;
                const shapeEl = textEl.closest('.shape');
                const shape = findShapeById(shapeEl.id);
                
                textEl.setAttribute('contenteditable', 'false');
                const newText = textEl.innerText;
                shape.text = newText;
                
                // Update properties panel if it's the selected shape
                if (shape.id === selectedShapeId) {
                    textInput.value = newText;
                }
                textEl.removeEventListener('keydown', onTextKeydown);
            }

            function onTextKeydown(e) {
                // Stop editing on Enter key
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            }
 
            // --- Connection Logic ---

            connectBtn.addEventListener('click', () => {
                isConnecting = !isConnecting;
                if (isConnecting) {
                    connectBtn.textContent = 'Cancel Connection';
                    connectBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                    connectBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                    canvas.style.cursor = 'crosshair';
                    selectShape(null); // Deselect
                } else {
                    resetConnectionState();
                }
            });

            function handleConnectionClick(shapeId) {
                if (!connectionStartShapeId) {
                    // This is the first shape
                    connectionStartShapeId = shapeId;
                    findShapeById(shapeId).element.classList.add('selected'); // Highlight start
                } else {
                    // This is the second shape
                    if (connectionStartShapeId !== shapeId) {
                        createLine(connectionStartShapeId, shapeId);
                    }
                    // Reset state
                    resetConnectionState();
                }
            }
            
            function resetConnectionState() {
                if (connectionStartShapeId) {
                    const startShape = findShapeById(connectionStartShapeId);
                    if (startShape) {
                        startShape.element.classList.remove('selected');
                    }
                }
                isConnecting = false;
                connectionStartShapeId = null;
                connectBtn.textContent = 'Connect Shapes';
                connectBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                connectBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                canvas.style.cursor = 'default';
            }
            
            function buildLine(lineData) {
                const { id, startShapeId, endShapeId } = lineData;
                
                const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                lineEl.id = id;
                lineEl.setAttribute('class', 'connector-line');
                lineEl.setAttribute('marker-end', 'url(#arrowhead)');
                
                svgLayer.appendChild(lineEl);

                // Store in state
                const newLine = {
                    id: id,
                    startShapeId: startShapeId,
                    endShapeId: endShapeId,
                    element: lineEl
                };
                lines.push(newLine);

                // Update shape connection lists
                const startShape = findShapeById(startShapeId);
                const endShape = findShapeById(endShapeId);
                
                if (startShape && endShape) {
                    startShape.connections.push({ lineId: id, endType: 'start' });
                    endShape.connections.push({ lineId: id, endType: 'end' });
                    
                    // Draw line immediately
                    updateLinePosition(id);
                } else {
                    // Handle error: shape not found (e.g., corrupt import)
                    console.warn(`Could not find shapes for line ${id}`);
                    lines = lines.filter(l => l.id !== id); // Remove bad line
                    lineEl.remove();
                }
            }

            function createLine(startShapeId, endShapeId) {
                const lineId = `line-${lineCounter++}`;
                buildLine({
                    id: lineId,
                    startShapeId: startShapeId,
                    endShapeId: endShapeId
                });
            }
            
            function deleteLine(lineId) {
                const line = findLineById(lineId);
                if (!line) return;
                
                // Remove from shape connection arrays
                const startShape = findShapeById(line.startShapeId);
                if (startShape) {
                    startShape.connections = startShape.connections.filter(c => c.lineId !== lineId);
                }
                const endShape = findShapeById(line.endShapeId);
                if (endShape) {
                    endShape.connections = endShape.connections.filter(c => c.lineId !== lineId);
                }
                
                // Remove from DOM
                line.element.remove();
                
                // Remove from state
                lines = lines.filter(l => l.id !== lineId);
            }

            function updateLinesForShape(shapeId) {
                const shape = findShapeById(shapeId);
                if (!shape) return;
                
                shape.connections.forEach(conn => {
                    updateLinePosition(conn.lineId);
                });
            }
 
            function updateLinePosition(lineId) {
                const line = findLineById(lineId);
                if (!line) return;

                const startShape = findShapeById(line.startShapeId);
                const endShape = findShapeById(line.endShapeId);
                if (!startShape || !endShape) return;
                
                const startCenter = getShapeCenter(startShape);
                const endCenter = getShapeCenter(endShape);
                
                // This is a simple implementation.
                // A more advanced one would find the intersection with the shape's bounding box.
                
                line.element.setAttribute('x1', startCenter.x);
                line.element.setAttribute('y1', startCenter.y);
                line.element.setAttribute('x2', endCenter.x);
                line.element.setAttribute('y2', endCenter.y);
            }
 
            // --- Clear Canvas ---
            function clearCanvas() {
                // Remove all shape elements
                shapes.forEach(shape => shape.element.remove());
                // Remove all line elements
                lines.forEach(line => line.element.remove());
                
                // Reset state
                shapes = [];
                lines = [];
                selectedShapeId = null;
                isConnecting = false;
                connectionStartShapeId = null;
                shapeCounter = 0;
                lineCounter = 0;
                
                // Reset UI
                selectShape(null);
                resetConnectionState();
            }
            
            clearBtn.addEventListener('click', clearCanvas);

            // --- Print Button ---
            printBtn.addEventListener('click', () => {
                window.print();
            });

            // --- YAML Export ---
            exportBtn.addEventListener('click', () => {
                exportDiagram();
            });

            function exportDiagram() {
                // 1. Create serializable shape data (omitting 'element' and 'connections')
                const exportableShapes = shapes.map(shape => ({
                    id: shape.id,
                    x: shape.x,
                    y: shape.y,
                    text: shape.text,
                    color: shape.color,
                    type: shape.type
                }));

                // 2. Create serializable line data (omitting 'element')
                const exportableLines = lines.map(line => ({
                    id: line.id,
                    startShapeId: line.startShapeId,
                    endShapeId: line.endShapeId
                }));

                // 3. Combine into one data object
                const diagramData = {
                    shapeCounter: shapeCounter,
                    lineCounter: lineCounter,
                    shapes: exportableShapes,
                    lines: exportableLines
                };

                // 4. Convert to YAML
                let yamlString = "";
                try {
                    yamlString = jsyaml.dump(diagramData);
                } catch (e) {
                    console.error("Error exporting to YAML:", e);
                    return; // Don't proceed if dump fails
                }

                // 5. Trigger download
                const blob = new Blob([yamlString], { type: 'text/yaml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'diagram.yml';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- YAML Import ---
            importInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const yamlString = event.target.result;
                    try {
                        const data = jsyaml.load(yamlString);
                        
                        if (!data || !Array.isArray(data.shapes) || !Array.isArray(data.lines)) {
                            throw new Error("Invalid YAML file structure.");
                        }
                        
                        // Valid data, proceed to load
                        loadDiagram(data);

                    } catch (e) {
                        console.error("Error importing YAML:", e);
                        // In a real app, you'd show a modal here
                    } finally {
                        // Reset file input to allow importing the same file again
                        e.target.value = null;
                    }
                };
                reader.readAsText(file);
            });

            function loadDiagram(data) {
                // 1. Clear the current canvas
                clearCanvas();

                // 2. Set the counters
                shapeCounter = data.shapeCounter || 0;
                lineCounter = data.lineCounter || 0;

                // 3. Rebuild all shapes
                data.shapes.forEach(shapeData => {
                    buildShape(shapeData);
                });

                // 4. Rebuild all lines
                // This must happen *after* all shapes are built
                data.lines.forEach(lineData => {
                    buildLine(lineData);
                });
            }

            // --- Utility Functions ---

            function findShapeById(id) {
                return shapes.find(s => s.id === id);
            }

            function findLineById(id) {
                return lines.find(l => l.id === id);
            }
            
            function getShapeCenter(shape) {
                // Get center based on state, not element, as element might be transforming
                return {
                    x: shape.x + shape.element.offsetWidth / 2,
                    y: shape.y + shape.element.offsetHeight / 2
                };
            }

        });
    </script>
</body>
</html>